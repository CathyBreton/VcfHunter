<h1 id="tutorial-for-vcfhunter">Tutorial for VcfHunter</h1>
<p>This tutorial go through all steps from variant calling from DNAseq and/or RNAseq to caracterization of genome mosaic structure using <strong><em>VcfHunter tools</em></strong></p>
<p>Go to the VcfHunter folder (Scripts can be run from any folder but the command lines in this tutorial assume you are in this folder and that you have python 2.7 and 3 versions).</p>
<h3 id="available-data">Available data:</h3>
<p><em>data/reference/</em> is a folder containing a fasta file with the reference sequence and a gff file containing the reference sequence annotation <em>data/reads/</em> is a folder containing DNAseq paired reads simulated from 3 gene pools of diploid ancestral accessions (11, 10 and 9 accessions from each gene pool respectively) and 10 DNAseq and 10 RNAseq paired reads simulated from hybrids diploids accessions resulting from several crosses of accessions from the ancestral pool. <em>data/config/</em> is a folder containing two configuration files needed for the RNAseq and DNAseq variant calling</p>
<p>A specific folder as been created to test the tools (<em>TestTools</em>). Go to this folder to run all command lines of this toolbox. But these tools can also be launched from everywhere you have permission to write, you will only have to change path to the configuration files.</p>
<p>For the following example, we will assume that you have a computer with 8 processors. If it is not the case or is you want to use less processors than available you should/can change the number of processors you allow the program to use.</p>
<p>In this tutorial we assume that you have performed the preliminary steps of checking your reads and filtered if necessary. After that, it is time to begin the variant calling.</p>
<h2 id="a---variant-calling">A - Variant calling</h2>
<p>Because different mapping tools are needed to perfom the mapping depending on the type of data (RNA or DNA), two different pipeline shoold be use for read mapping and post mapping processing.</p>
<h3 id="dna-seq-variant-calling">DNA seq variant calling</h3>
<p>a - Mapping of the DNA reads: In this step, reads are aligned against the reference sequence using BWA mem algorithm</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s a</code></pre>
<p>40 folders have been created containing each:</p>
<ul>
<li>*.sam.stat files with mapping statistics</li>
<li>*_merged.bam file containing aligned read merged in one bam file</li>
<li>*_merged.bai file (index of the bam file)</li>
<li>STAT folder containing a .html file summarising statistics on libraries.</li>
</ul>
<p>b - Removing duplicates reads: In this step, read duplicates are removed</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s b</code></pre>
<p>3 new files have been added in each folders:</p>
<ul>
<li>*_rmdup.bam file containing non redundant reads resulting from PCR and optical duplicates</li>
<li>*_rmdup.bai file (index of the bam file)</li>
<li>*_duplicate file summarising read duplication statistics</li>
</ul>
<p>c - Removing duplicates reads: In this step, read are realigned around indels</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s c</code></pre>
<p>2 new files have been added in each folders:</p>
<ul>
<li>*_realigned.bam file reads realigned around indels</li>
<li>*_realigned.bai file (index of the bam file)</li>
</ul>
<p>d - Base recalibration: In this step, reads base sequencing quality are recalculated. <strong>This step is recommended by GATK best practice but we do not recommend to use it if you use our pipeline.</strong></p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s d</code></pre>
<p>5 new files have been added in each folders:</p>
<ul>
<li>*_real_recal.bam file reads bases recalibrated</li>
<li>*_real_recal.bai file (index of the bam file)</li>
<li>*_recalibration_plot.pdf file</li>
<li>*_selected.vcf file containing variant sites used for base recalibration (if no vcf have been provided)</li>
<li>*_selected.vcf.idx file (index of the vcf file)</li>
</ul>
<p>e - Allele counting: In this step, reads are used to count for each covered sites the number of reads supporting each bases (A,T,G,C,N,*=deletion).</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s e</code></pre>
<p>Several new files have been added in each folders:</p>
<ul>
<li>*.gz files recording, for each chromosomes/sequences in the fasta provided as reference, the count of the number of reads supporting each bases (A,T,G,C,N,*=deletion) at each covered site.</li>
</ul>
<p>f - Vcf generation: generate the vcf for all accessions in the configuration file</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s f</code></pre>
<p>Several new files in the current directory:</p>
<ul>
<li>prefix_*_all_allele_count.vcf file for each chromosomes/sequences in the fasta provided as reference.</li>
</ul>
<p>g - Vcf merging: generate a single vcf from all chromosome/sequences in the fasta provided as reference. This step is not needed here has only one sequence is passed but you can try the command line anyway ;-)</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s g</code></pre>
<p>1 new file is created in the current directory:</p>
<ul>
<li>prefix_all_allele_count.vcf file</li>
</ul>
<p>h - Statistics: Compute mapping statistics</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s h</code></pre>
<p>Several new files in the current directory:</p>
<ul>
<li>*_lib.stats file containing mapping statistics per libraries</li>
<li>*_acc.stats file containing mapping statistics per accessions</li>
</ul>
<p><strong><em>All the steps can be lauched in one command line. First remove the generated files:</em></strong></p>
<pre><code>rm -rf *</code></pre>
<p>Run the pipeline again (without step d)</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNAseq.conf -t 8 -p DNAseq -s abcefgh</code></pre>
<h3 id="rna-seq-variant-calling">RNA seq variant calling</h3>
<p>a - Reference indexation: Create an index for STAR RNAseq mapping</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s a</code></pre>
<p>1 folder is created in the current directory (name = prefix+<em>ref</em>star_1). This folder contains index constructed and used by STAR to align RNAseq reads</p>
<p>b - Identification of splicing sites. During this step, all reads from all libraries are merged and aligned against the reference sequence which allowed STAR to identify splicing sites which will be used to build a new index (step c) taking in account the splicing site.</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s b</code></pre>
<p>A file (prefix+&quot;<em>JUNC</em>ESTIMATION_SJ.out.tab&quot;) containing the splicing sites is generated</p>
<p>c - Reference indexation: with the splicing site information</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s c</code></pre>
<p>1 folder is created in the current directory (name = prefix+<em>ref</em>star_2). This folder contains index constructed and used by STAR to align RNAseq reads</p>
<p>d - Read mapping: Reads are aligned against the reference sequence using STAR software</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s d</code></pre>
<p>10 folders have been created containing each:</p>
<ul>
<li>*Aligned.out.sam files containing aligned reads (1 per libraries)</li>
<li>*Log.final.out file containing mapping statistics of STAR (1 per libraries)</li>
<li>*.SJ.out.tab file containing splicing sites (1 per libraries)</li>
</ul>
<p>1 additional folder was created and named as passed to -p option containing a file named prefix + &quot;_mapping.tab&quot; which summarise mapping statistics for all accessions.</p>
<p>e - Read merging and ordering: Reads from different libraries but the same accessions are merged and sorted on coordinate.</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s e</code></pre>
<p>Several new files have been added in each folders:</p>
<ul>
<li>*_merged.bam files containing all aligned reads from all libraries of one accession.</li>
<li>*_merged.bai files (index of the bam file)</li>
</ul>
<p>f - Removing duplicates reads: In this step, read duplicates are removed</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s e</code></pre>
<p>2 new files have been added in each folders:</p>
<ul>
<li>*_rmdup.bam file containing non redundant reads resulting from PCR and optical duplicates</li>
<li>*_duplicate file summarising read duplication statistics</li>
</ul>
<p>An additional file was created in the folder named as passed to -p option. This file named prefix + &quot;<em>rmdup</em>stat.tab&quot; contained duplicates statistics for all accessions.</p>
<p>g - Bam reordering: In this step, is necessary for subsequent steps</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s g</code></pre>
<p>2 new files have been added in each folders:</p>
<ul>
<li>*_reorder.bam file containing reordered reads based on the order sequences are provided in the multifasta</li>
<li>*_reorder.bai file (index of the bam file)</li>
</ul>
<p>h - Reads splitting: In this step, reads are splitted on splicing sites</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s h</code></pre>
<p>2 new files have been added in each folders:</p>
<ul>
<li>*_trim.bam file containing splitted reads</li>
<li>*_trim.bai file (index of the bam file)</li>
</ul>
<p>i - Indel realigment: In this step, reads realigned around indels. Countrary to <strong>process_reseq</strong> a vcf on known indel could not be provided. It will be implemented in futur...</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s i</code></pre>
<p>2 new files have been added in each folders:</p>
<ul>
<li>*_realigned.bam file containing realigned reads</li>
<li>*_realigned.bai file (index of the bam file)</li>
</ul>
<p>j - Allele counting: In this step, reads are used to count for each covered sites the number of reads supporting each bases (A,T,G,C,N,*=deletion).</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s j</code></pre>
<p>Several new files have been added in each folders:</p>
<ul>
<li>*.gz files recording, for each chromosomes/sequences in the fasta provided as reference, the count of the number of reads supporting each bases (A,T,G,C,N,*=deletion) at each covered site.</li>
</ul>
<p>k - Vcf generation: generate the vcf for all accessions in the configuration file</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s k</code></pre>
<p>Several new files in the current directory:</p>
<ul>
<li>prefix_*_all_allele_count.vcf file for each chromosomes/sequences in the fasta provided as reference.</li>
</ul>
<p>l - Vcf merging: generate a single vcf from all chromosome/sequences in the fasta provided as reference. This step is not needed here has only one sequence is passed but you can try the command line anyway ;-)</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s l</code></pre>
<p>1 new file is created in the current directory:</p>
<ul>
<li>prefix_all_allele_count.vcf file</li>
</ul>
<p>m - Exon coverage: Calculate for each gene filled in the gff file passed in the configuration file and for each accessions, the proportion of the exon covered by the library.</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p RNAseq -s m</code></pre>
<p>1 new file is created in the current directory:</p>
<ul>
<li>prefix_all_allele_count.vcf file</li>
</ul>
<p><strong><em>All the steps can be launched in one command line. First remove the generated files:</em></strong></p>
<pre><code>rm -rf sample71 sample72 sample73 sample74 sample75 sample76 sample77 sample78 sample79 sample80</code></pre>
<p>Run the pipeline again</p>
<pre><code>python2 ../bin/process_RNAseq.1.0.py -c ../data/config/RNAseq.conf -t 8 -p DNAseq -s abcdefghijklm</code></pre>
<p><strong><em>RNAseq and DNAseq bam can be used to generate a single vcf:</em></strong> At this stage we assume that RNAseq and DNAseq have been processed until step j and e for <strong>process_RNAseq</strong> and <strong>process_reseq respectively</strong>. To generate a single vcf a new configuration file should be created containing informations for RNAseq and DNAseq accession. This file is available in <em>data/config/DNA_RNAseq.conf</em>. To obtain the vcf run the following command line:</p>
<pre><code>python2 ../bin/process_reseq_1.0.py -c ../data/config/DNA_RNAseq.conf -t 8 -p DNA_RNAseq -s fg</code></pre>
<h2 id="b---vcf-prefiltering">B - VCF prefiltering</h2>
<p>Once the variant calling is performed, it is now time to filter the calling. This is a necessary step with this pipeline because all variant sites are reported (one read, on one accession supporting a variant). The phylosophie of <strong><em>process_RNAseq</em></strong> and <strong><em>process_reseq</em></strong> is to report all variant sites and then decide to filter the vcf (what is error and what is not) based on understandable and simple parametres using <strong><em>VcfPreFilter</em></strong> tool. For the following step we will work on the vcf file generated on both DNA and RNA seq data. VcfPreFilter can be launched as followed:</p>
<pre><code>python2 ../bin/VcfPreFilter.1.0.py -v DNA_RNAseq_all_allele_count.vcf -m 10 -M 10000 -f 0.05 -c 3 -o DNA_RNAseq_prefiltered.vcf</code></pre>
<p>The outpout is a vcf file (named as filled in -o option) in which the variant line are filtered as followed:</p>
<ul>
<li>1 - an accession of a variant line is considered only if its site coverage is comprised in [-m : -M] (in this example [10:10000]),</li>
<li>2 - for each considered accession, an allele is considered only if its frequency at in the accession if equal or greater than -f (in this example: 0.05) and its coverage is equal or greater than -c (in this example: 3),</li>
<li>3 - the line is kept only if their is at least one allele different from the reference kept in at least one accession at the end of the process,</li>
</ul>
<p>The variant calling is recalculated <strong>for each accessions</strong> based on selected alleles (even accessions which are not enough covered according our parameters will have a genotype). An additional tag (GC) is added in the FORMAT column of the VCF. This tag is calculated as followed : -log10(best genotype probability) + log10(second best genotype probability) and give an idea of the quality of the calling at the datapoint.</p>
<h2 id="c---vcf-statistics">C - VCF statistics</h2>
<p>Now that we have a vcf file in which we have only kept variant lines in which we are relatively confident, it is time to perform some statistics on the vcf. To do so, we first need to create a file in which we list accessions to perform statistics on. This can be done with the following command line:</p>
<pre><code>head -n 1000 DNA_RNAseq_prefiltered.vcf | grep &quot;#CHROM&quot; | sed &#39;s/\t/\n/g&#39; | tail -n 50 &gt; all_names.tab</code></pre>
<p>Statistics calculation can be done with the following command line:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --vcf DNA_RNAseq_prefiltered.vcf --names all_names.tab --type STAT --prefix DNA_RNAseq_prefiltered</code></pre>
<p>2 files are generated:</p>
<ul>
<li>prefix+&quot;_general.stat&quot; which regroup global statistics</li>
<li>prefix+&quot;_accession.stat&quot; which regroup statistics per accessions such as missing data, accession specific alleles, homozygous sites and heterozygous sites.</li>
</ul>
<p>When looking at the prefix+&quot;_general.stat&quot; file we observe that there is around 60000 sites in which we detected only one allele. This suggests that either this is reference specific alleles or sequencing errors or that it is monomorphous sites that have been identified polymorphous based on the criteria passed in during vcf prefilter (but binomial probabilities identified monorphous).</p>
<p>2 solution are available:</p>
<ul>
<li>running again <strong><em>VcfPreFilter</em></strong> with more stringent parameters</li>
<li>filtering the vcf removing monoallelic variant. This is the solution we will choose in this tutorial.</li>
</ul>
<p>In this same filtering step, we will also identify variant sites in which we dont have enough confidence (--MinCov and MinAl options) and we will remove also tri-allelic sites. To perform the filter, run the following command line:</p>
<pre><code>python3 ../bin/vcfFilter.1.0.py --vcf DNA_RNAseq_prefiltered.vcf --names all_names.tab --MinCov 10 --MinAl 3 --nMiss 50 --RmAlAlt 1:3 --prefix DNA_RNAseq_prefiltered</code></pre>
<p>The output is a filtered vcf file (prefix+&quot;_filt.vcf&quot;) in which all mono- or tri- allelic lines are removed. In addition, all datapoints which have a coverage lower than 10 reads or a minor allele frequency lower than 3 reads are converted to missing data.</p>
<p>We will perform a final filter on the vcf file because the analysis that perform the chromosome painting does not support the missing data. Because the vcf is a mix of DNA and RNAseq, the accession genotyped with the RNAseq will have more missing data. In this context we will filter the DNAseq accession for no missing data. This is not clear why we do that only on the DNAseq but it will become clearer and clearer along the process why we do that.</p>
<p>So to filter the vcf on DNAseq data only we should generate 2 files. A file which regroup accession names to use for filtering (DNAseq accession) and accessions we do not want to use for filtering but which we want to keep in the vcf anyway (RNAseq accessions). This can be done with the following command line:</p>
<pre><code>grep Lib ../data/config/DNAseq.conf | cut -f 3 &gt; DNAseq_names.tab
grep Lib ../data/config/RNAseq.conf | cut -f 3 &gt; RNAseq_names.tab</code></pre>
<p>And to perform the filter, run the following command line:</p>
<pre><code>python3 ../bin/vcfFilter.1.0.py --vcf DNA_RNAseq_prefiltered_filt.vcf --names DNAseq_names.tab --outgroup RNAseq_names.tab --MinCov 10 --MinAl 3 --nMiss 0 --RmAlAlt 1:3 --prefix DNA_RNAseq_final</code></pre>
<p>The output is a filtered vcf file (prefix+&quot;_filt.vcf&quot;) in which there is no missing datas for the DNAseq accession but it remains missing data for RNAseq data. You can calculate statistics if you want:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --vcf DNA_RNAseq_final_filt.vcf --names all_names.tab --type STAT --prefix DNA_RNAseq_final_filt</code></pre>
<h2 id="d---pca-analysis">D - PCA analysis</h2>
<p>Now that we have a &quot;good&quot; vcf in which we are confident in the variant line, it is time to analyse the dataset. In another way to say: to perform the chromosome painting! The fisrt step of the chromosome painting is to perform a COA analysis on the dataset to cluster the alleles and the accession. Create a folder in which the analysis will be performed and run the following command line:</p>
<pre><code>mkdir AllClust
python3 ../bin/vcf2struct.1.0.py --vcf DNA_RNAseq_final_filt.vcf --names DNAseq_names.tab --type FACTORIAL --prefix AllClust/ClustAnalysis --nAxes 6 --mulType coa</code></pre>
<p>The last command line run the factorial analysis (--type FACTORIAL option). During this analysis the vcf file is recoded as followed: For each allele at each variants site two markers were generated; One marker for the presence of the allele (0/1 coded) and one for the absence of the allele (0/1 coded).</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig3.png" />
</div>
<p>Only alleles present or absent in <strong>part</strong> (not all) of selected accessions were included in the final matrix file named <strong><em>AllClust/ClustAnalysis_matrix_4_PCA.tab</em></strong> in this example. An additional column named &quot;GROUP&quot; can be identified. This column is filled with &quot;UN&quot; value if no --group argument is passed. We will explain later this arguement.</p>
<p>The factorial analysis (here a COA, --mulType option) was performed on the transposed matrix using R (The R script is generated by the sript and can be found here: <strong><em>AllClust/ClustAnalysis_multivariate.R</em></strong>). R warning messages and command lines are recorded in the file named <strong><em>ClustAnalysis_multivariate.Rout</em></strong>. Graphical outputs of the analysis were draw and for example accessions and alleles can be projected along axis in the following picture.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig4.png" />
</div>
<p>In this example the left graphe represent accessions projected along axis 1 and 2 and the right represent the allele projected along synthetic axis. A graphical representation is performed for each axis combinations and each file is named according to the following nomenclature <strong><em>prefix + _axis_X_vs_Y.pdf</em></strong>. Several pdf for accessions along axis only is also generated and are named according to the following nomenclature <strong><em>prefix + _axis_X_vs_Y_accessions.pdf</em></strong>.</p>
<p>The cumulated inertia is plotted in the graphe named <strong><em>AllClust/ClustAnalysis_inertia.pdf</em></strong></p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig5.png" />
</div>
<p>Individual and variables coordinates for the selected 6 fisrt axis (--nAxes option) are recorded in files named <strong><em>AllClust/ClustAnalysis_individuals_coordinates.tab</em></strong> and <strong><em>AllClust/ClustAnalysis_variables_coordinates.tab</em></strong> respectively. A third file named <strong><em>AllClust/ClustAnalysis_variables_coordinates.tab</em></strong> containing allele scaled coordinates (colums centered and reduced) along synthetic axis is generated.</p>
<h3 id="the---group-option">The --group option</h3>
<p>We assume that in some case you have additionnal informations on your dataset such as which accessions are adimxed and which accessions are likely to be the ancestral one. And maybe you want to verify/project this information in your analysis. This can be done passing a configuration file with two section to the --group option. This file can be found in the data/config/ folder and is named <strong><em>AncestryInfo.tab</em></strong>. You can have a look at the file if you want but basically the two sections are named [group] and [color] and contained respectively the accession suspected grouping and a color (in RGB proportion) you want to attribute to each group. Accessions with no group should filled with &quot;UN&quot; value. <strong>Warning: group name should be written in upper case (du to R sorting)</strong>.</p>
<p><strong>This additional information will not change the results of the analysis.</strong> It will only add color to the figures and fill the GROUP column: in the GROUP column alleles groups were attributed based on the following rule: the allele is attributed to a group if it is only present in this group but not in other defined groups.</p>
<p>you can try this option running the following command line:</p>
<pre><code>mkdir AllClust_group
python3 ../bin/vcf2struct.1.0.py --vcf DNA_RNAseq_final_filt.vcf --names DNAseq_names.tab --type FACTORIAL --prefix AllClust_group/ClustAnalysis --nAxes 6 --mulType coa --group ../data/config/AncestryInfo.tab</code></pre>
<p>Outpout are strictely the same with two exceptions: pdf files are colorated according to the groups passed in --group option. And the &quot;GROUP&quot; column has been filled if the grouping rules are fulfilled.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig6.png" />
</div>
<p>You can observe that if you compare this example with the preceding one that only the orientation of the axis changed but the accessions and allele coordiantes remained the same.</p>
<h2 id="d---allele-clustering">D - Allele clustering</h2>
<h3 id="mean-shift-clustering">Mean Shift clustering</h3>
<p>Now that allele have been projected along synthetic axes, it is time to clusterize these alleles. The idea is that the structure reflected by the synthetic axis represent the ancestral structure. In this context, the alleles at the extremities of the cloud of points will be the ancestral ones. These alleles can be clusterized using several approaches. In this turorial we will use a Mean Shift clustering approach.</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type SNP_CLUST-MeanShift --VarCoord AllClust/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat AllClust/ClustAnalysis_matrix_4_PCA.tab --thread 8 --prefix AllClust/ClustAnalysis</code></pre>
<p>The Mean Shift clustering is performed with only the 2 first axes of the COA (--dAxes 1:2) because the analysis showed that most of the inertia is on these axes. With a mean shift approach, the number of group is automatically detected.</p>
<p>During the process, several informations are returned to stdout, but at the end of the process three main informations are returned: (i) the number of alleles used for the analysis. Allele present or absent in all accessions are removed. (ii) the number of estimated clusters which can be found in the line:</p>
<pre><code>number of estimated clusters : 3</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>the number of allele grouped within each group is returned and should look like as followed:</li>
</ol>
<!-- -->

<pre><code>Group g0 contained 11439 dots
Group g1 contained 2060 dots
Group g2 contained 1657 dots</code></pre>
<p>These results suggested a large desequilibrium in the grouping and we will discuss latter the reason of such desequilibrium. We will focus at the moment on the output and on the way we can interpret the analysis. Five file are generated and can be found in the <strong>AllClust</strong> folder:</p>
<ul>
<li><strong>ClustAnalysis_kMean_allele.tab</strong> file which correspond to the <strong><em>ClustAnalysis_matrix_4_PCA.tab</em></strong> in which the allele grouping has been recorded.</li>
<li><strong>ClustAnalysis_centroid_coordinates.tab</strong> file which regroup the centroids coordinates.</li>
<li><strong>ClustAnalysis_centroid_iteration_grouping.tab</strong> file which records for each centroid its grouping.</li>
<li><strong>ClustAnalysis_group_color.tab</strong> file that attribute a color to the groups.</li>
<li><strong>ClustAnalysis_kMean_gp_prop.tab</strong> file that report for each allele the probability to be in each groups. This is not a &quot;real&quot; probability, the idea was to have a statistics in case you want to filter alleles. This value was calculated as the inverse of the euclidian distance of one point and each centroids and these values were normalized so that the sum is equal to 1.</li>
</ul>
<h3 id="clustering-visualization">Clustering visualization</h3>
<p>The clustering visualization can be performed using 2 tools of vcf2struct, a 2d visualization can be performed with --type VISUALIZE_VAR_2D, and a 3d interactive visualization can be performed using --type VISUALIZE_VAR_3D. The 2d of centroids visualization can be launched with the following command line on centroids.</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type VISUALIZE_VAR_2D --VarCoord AllClust/ClustAnalysis_centroid_coordinates.tab --dAxes 1:2 --mat AllClust/ClustAnalysis_centroid_iteration_grouping.tab --group AllClust/ClustAnalysis_group_color.tab --prefix AllClust/CentroidGrouping</code></pre>
<p>Output is as much files as axis combinations named according to the following nomenclature <strong><em>prefix + _axisX_vs_axisY.png</em></strong>. The output should look like this:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/CentroidGrouping_axis1_vs_axis2.png" />
</div>
<p>This Figure represent the centroids location. Colors may not be the same when you run the analysis because the color attribution is random.</p>
<p>Visualization of the allele grouping can be done as followed:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type VISUALIZE_VAR_2D --VarCoord AllClust/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat AllClust/ClustAnalysis_kMean_allele.tab --group AllClust/ClustAnalysis_group_color.tab --prefix AllClust/AlleleGrouping</code></pre>
<p>The outpout named <strong><em>prefix + _axis1_vs_axis2.png</em></strong> look like this (color may be different):</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/AlleleGrouping_axis1_vs_axis2.png" />
</div>
<p>In this picture you have the representation of the allele clustering performed by the Mean Shift approach. We can clearly observe that the red group (g0) is over-represented and may be split in two to have alleles representing ancetral group g0 and en central cluster in which allele not fixed/not representing ancestral groups are clustered.</p>
<p>As in this example we choose to work only with 2 axis, it is not necessary to have a 3d visualization but we can try the command anyway:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type VISUALIZE_VAR_3D --VarCoord AllClust/ClustAnalysis_variables_coordinates.tab --dAxes 1:2:3 --mat AllClust/ClustAnalysis_kMean_allele.tab --group AllClust/ClustAnalysis_group_color.tab</code></pre>
<p>A window which should look like this should open:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig7.png" />
</div>
<p>This 3d visualisation can be rotated with the mouse.</p>
<h3 id="important-remark">Important remark</h3>
<p>In this example we observed that the allele of the g0 group are over represented. And maybe this group should be splitted. In fact this group should be splitted as there is 3 ancestral groups in the simulated data! In real dataset you don't have this information but an admixture or SNMF analysis can be carried first which should give you an idea of the group number you expect. In addition the overrepresentation of a group (which is not at the center of the datapoint) is a strong indicator of problem in allele grouping! This problem in grouping may be due to the strong contribution of this group to the hybrid accessions (cf accessions projection along synthetic axis) and/or a structuration in hybrid accessions that generate noise in wild accessions structure or problem in calibration of the clustering (in this example here: estimation of the bandwidth). This is a problem because during chromosome painting, g0 regions may be over represented and/or the chromosome painting may represent a structure that is not related to the ancestral contribution but rather a mix between ancestral contribution and hybrid structure!!! In this context, it may be clever test several clustering parameters until you reach the good number of cluster and even to re-run the COA analysis and clustering clustering but only on accessions that are not supposed hybrids to have a better allele grouping and ultimately a better chromosome painting.</p>
<p>At this point, you may ask why not suggesting to do this directely as I knew this will happen in our dataset. To this I respond that it is not so long to run and this example provide a limit of the method explained here that you should take in account! The idea is that you can try several multivariate analysis and clustering methods and check which method group the best your alleles.</p>
<p>We will do this in several steps: Firts we will vary the --quantile parameter which will allow to change bandwidth estimation parameter used in mean shift clustering. By default this value is put to 0.2. Lowering it should allow to have more clusters. Try the following command line:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type SNP_CLUST-MeanShift --VarCoord AllClust/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat AllClust/ClustAnalysis_matrix_4_PCA.tab --thread 8 --prefix AllClust/ClustAnalysis --quantile 0.1</code></pre>
<p>The output should look like this:</p>
<pre><code>loading modules
modules loaded
number of estimated clusters : 5
Printing files
Group g0 contained 9329 dots
Group g1 contained 2124 dots
Group g2 contained 1954 dots
Group g3 contained 850 dots
Group g4 contained 899 dots</code></pre>
<p>At this point you have 5 clusters, while in theory you expected 4 (3 corresponding to ancestral groups and 1 corresponding to unassigned alleles). This clustering can be visualized using the following command line:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type VISUALIZE_VAR_2D --VarCoord AllClust/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat AllClust/ClustAnalysis_kMean_allele.tab --group AllClust/ClustAnalysis_group_color.tab --prefix AllClust/AlleleGrouping</code></pre>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/sub1_AlleleGrouping_axis1_vs_axis2.png" />
</div>
<p>You can observe that g3 and g4 are close and could be merged if we want 4 clusters. I don't say that it is the solution but for our example, we will take this assertion. The idea is just to show you how to use the program and the different command line. So, to reduce the cluster number, we should increase the quantile value. We should then look a value between 0.1 and 0.2. Let's take 0.15!</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type SNP_CLUST-MeanShift --VarCoord AllClust/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat AllClust/ClustAnalysis_matrix_4_PCA.tab --thread 8 --prefix AllClust/ClustAnalysis --quantile 0.15</code></pre>
<p>The output should look like this:</p>
<pre><code>loading modules
modules loaded
number of estimated clusters : 4
Printing files
Group g0 contained 9427 dots
Group g1 contained 2196 dots
Group g2 contained 1892 dots
Group g3 contained 1641 dots</code></pre>
<p>This time we have the expected group number. Data visualization should be like this:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type VISUALIZE_VAR_2D --VarCoord AllClust/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat AllClust/ClustAnalysis_kMean_allele.tab --group AllClust/ClustAnalysis_group_color.tab --prefix AllClust/AlleleGrouping</code></pre>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/sub2_AlleleGrouping_axis1_vs_axis2.png" />
</div>
<p>We have an over represented central group g0, which correspond to unassigned alleles. However, we can observe that the group g2 is steel a little over-represented. This can be due to the presence of admixed accessions with a strong contribution of this ancestral group, that perturbate the multivatiate analysis. We can try to solves this problem by running again the analysis but this time only on homogeneous/ancestral accessions. This is what we will do in the next point.</p>
<h2 id="e---runnig-again-multivariate-analysis-and-clustering">E - Runnig again Multivariate analysis and clustering</h2>
<p>First we need to create a new name file in which their will only be &quot;ancestral&quot; accessions. Some accession may have introgression but they should not be to much (this can be verified with several methods such as the first COA, adixture or SNMF analysis). In this example, we the COA analysis, we observed that acccession from sample61 to sample70 seemed not &quot;pure&quot;. I also know this from the simulations we have made to generate the dataset ;-). These accessions should be removed from the name file. To do this, run :</p>
<pre><code>head -n 31 DNAseq_names.tab &gt; DNAseqFinalName.tab</code></pre>
<p>Once this is done do again the Multivariate analysis:</p>
<pre><code>mkdir Final
python3 ../bin/vcf2struct.1.0.py --vcf DNA_RNAseq_final_filt.vcf --names DNAseqFinalName.tab --type FACTORIAL --prefix Final/ClustAnalysis --nAxes 6 --mulType coa --group ../data/config/AncestryInfo.tab</code></pre>
<p>When you look at the <strong><em>Final/ClustAnalysis_axis_1_vs_2_accessions.pdf</em></strong>, you can observe that accessions are separated on the 2 axis with no intermediate accessions that could perturbate the analysis.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig8.png" />
</div>
<p>And the clustering:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type SNP_CLUST-MeanShift --VarCoord Final/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat Final/ClustAnalysis_matrix_4_PCA.tab --thread 8 --prefix Final/ClustAnalysis  --quantile 0.15

loading modules
modules loaded
number of estimated clusters : 4
Printing files
Group g0 contained 9134 dots
Group g1 contained 1837 dots
Group g2 contained 1899 dots
Group g3 contained 1957 dots</code></pre>
<p>At this point you can observe that we have 4 clusters and clusterised allele are more homogenous with one over-represented group (g0) corresponding to unassigned alleles (in the center of the cloud of point). You can observe centroids and allele clusering with the previously described command lines:</p>
<pre><code>python3 ../bin/vcf2struct.1.0.py --type VISUALIZE_VAR_2D --VarCoord Final/ClustAnalysis_centroid_coordinates.tab --dAxes 1:2 --mat Final/ClustAnalysis_centroid_iteration_grouping.tab --group Final/ClustAnalysis_group_color.tab --prefix Final/CentroidGrouping
python3 ../bin/vcf2struct.1.0.py --type VISUALIZE_VAR_2D --VarCoord Final/ClustAnalysis_variables_coordinates.tab --dAxes 1:2 --mat Final/ClustAnalysis_kMean_allele.tab --group Final/ClustAnalysis_group_color.tab --prefix Final/AlleleGrouping</code></pre>
<p>The resulting centroid grouping:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/FinaleCentroidGrouping_axis1_vs_axis2.png" />
</div>
<p>The final allele grouping:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/FinaleAlleleGrouping_axis1_vs_axis2.png" />
</div>
<h2 id="f---performing-the-chromosome-painting">F - Performing the chromosome painting</h2>
<p>Now that allele are clusterized, it is time to perform the chromosome painting. The idea is to count, on a sliding window along chromosomes, the number of grouped alleles of each groups for each hybrid accession and then to attribute a chromosome region origin based on the maximal grouped alleles. However it is not so simple, determining the expected grouped allele number is not necessary an easy task: Sometime the representant of the ancestral groups are very few, or the diversity of these groups is not well represented or the degree of ancestral allele fixation is not the same between accession depending if the accessions are allogamous or autogamous. This program has been designed to solve these problems (at least try) as explained in the following Figure:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig9.png" />
</div>
<p>This figure explained the impact of an unbalance in the allele fixation levels of ancestral population on the expectation of grouped allele number at a position. We can observe that depending on the allele fixation level in the population, for the same number of allele grouped, the expected allele number of Gp2 is lower than Gp1 because all alleles of Gp2 are not fixed! In the case you have a large sample of your ancestral populations, estimating the expected grouped allele number on the window is relatively easy, but this is not always the case. In this context the program try to recreate the ancestral population from the few representatives provided. This can be done by simulating ancestral (our programs creates populations or 100 individuals) based on alleles sampling from ancestral population representatives. Then in each populations, the mean and standard deviation number of grouped alleles is calculated on given window size which give the expectation of grouped alleles on these windows to attribute 1, 2, 3, ... haplotypes. This simulation step can be called with the <em>-T Simul</em> option in the program. Because this simulation step is long and because sampling alleles at a site followed a binomial test, the mean and sd expected groups at a site, can be directely calculated from grouped alleles at the site. Then the expected number of grouped alleles on a window is the sum of the mean value obtained at a site. However, the standard deviation on the window is not easy to calculate and then this value is approximated by calcutating the square root of the sum of the variances at each sites of the windows. This algorithm as also been implemented in our program and can be called with <em>-T Binom</em> option. Because the estimation of standard deviation is not completly satisfactory we also added a <em>--prop</em> option which allowed to define an arbitrary <em>standard deviation</em> value calculated as --prop * Mean_Expected_value. All these calculations or simulations are also done for hybrids population, to estimate the number of grouped alleles in case of several ancestral origin at a site (example: one haploype of Gp1 and one haplotype of Gp2).</p>
<p>An additional complexity level is that depending on the sampling of the ancestral representative of the ancestral groups, the variance of the expected number of alleles of a group can be greatly underestimated as well as the mean value (cf Figure below). In this context, the --prop value may be more appropriate.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig10.png" />
</div>
<p>This figure showed the impact of the ancestral accession sampling on the simulating of ancestral population. To partially solve this problem, we chose to attribute the maximal variance found in a group and on a window, to all groups in the same window.</p>
<p>After this short introduction, it is time to try the command line! First you need to create a file which identify which accession belong to which ancestral group. This can be donne by comparing the clustering and accession grouping. In the following picture we showed the clustering of alleles and accession projections allong synthetic axis.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig10bis.png" />
</div>
<p>In this picture we can observe that sample1 to sample20 are accession corresponding to the group <strong>g1</strong>, accessions from sample21 to sample40 belonged to group <strong>g2</strong> and accessions from sample41 to sample 49 corresponded to group <strong>g3</strong>. You can create this file manually, by because I am lazy and I already have a preformated file, you can simply run the following command line:</p>
<pre><code>grep sample ../data/config/AncestryInfo.tab | sed &#39;s/X1/g1/&#39; | sed &#39;s/Y1/g2/&#39; | sed &#39;s/Z1/g3/&#39; | grep -v &#39;UN&#39; &gt; ancestor.gp</code></pre>
<p><strong>Be carreful, as the group attribution is random, you will have to check to which group (X1, Y1 and Z1) correspond the allele group (g0, g1, g2 and g3) to adjust the command line</strong></p>
<p>Once this file is ready, it is time to run the chromosome painting. In this example, we will use the fast algorithm (<em>-T Binom</em> option). This can be done with the *<strong>vcf2linear.1.1.py</strong> program by running the following command line:</p>
<pre><code>mkdir Painting
python3 ../bin/vcf2linear.1.1.py --vcf DNA_RNAseq_final_filt.vcf --names DNAseq_names.tab --namesH ancestor.gp --win 50 --mat Final/ClustAnalysis_kMean_allele.tab --prefix Painting --gcol Final/ClustAnalysis_group_color.tab --chr RefSeq --ploidy 2 -t 8 -T Binom</code></pre>
<p>Several output are generated in the <strong><em>Painting</em></strong> folder. For each accessions name in the <strong><em>DNAseq_names.tab</em></strong> file, a file named according to the following nomenclature <strong><em>prefix_accessionName_chr.tab</em></strong> is generated. This file record, for each allele at the center of the window of 101 (--win 50 means a window of 50 alleles before and after the considered allele), the number of counted grouped alleles in the accession for each groups (g1, g2, g3), the expected grouped alleles in case of only one haplotype (<strong>H1</strong>) of the considered group is expected (Loc-mu-H1-g3, Loc-mu-H1-g1, Loc-mu-H1-g2), the corresponding standard deviation value (Loc-sd-H1-g3, Loc-sd-H1-g1, Loc-sd-H1-g2) and the maximal standard deviation retained (Loc-max-sd-H1). Depending on the ploidy level of the studied accessions (--ploidy) these values are calculated for 2 haplotypes of a same group (<strong>H2</strong>), 3 haplotypes (<strong>H3</strong>), 4 haplotypes (<strong>H4</strong>), ... These values are followed by a column named <em>hetero</em>, which calculated the heterozygosity level in the window (proportion of heterozygous sites). Then, probalility to have at least 1, 2, 3, ... (depending on the --ploidy option) haplotypes for each group is rapported (Prob-H1-g3, Prob-H1-g1, Prob-H1-g2) for at least one haplotype and (Prob-H2-g3, Prob-H2-g1, Prob-H2-g2) for at least 2 haplotypes. The expected counted alleles of a group resulting from noise is calculated in all simulated accessions (in case of simulation) that have no contributors of these groups or based on the sum of the binomial expected values calculated as the number of time an allele of a group appear in individuals of other groups. The mean values are reported in columns named : <em>Loc-mu-noise-g3</em>, <em>Loc-mu-noise-g1</em>, <em>Loc-mu-noise-g2</em> and the coresponding standard deviation can be found in columns named : <em>Loc-sd-noise-g3</em>, <em>Loc-sd-noise-g1</em>, <em>Loc-sd-noise-g2</em>. The maximal variance is also reported in column <em>Loc-max-sd-noise</em>. These values allowed to calculate the probability that the counted alleles of a group is from noise and these values are reported in column named: <em>Prob-noise-g3</em>, <em>Prob-noise-g1</em>, <em>Prob-noise-g2</em>.</p>
<p>Haplotype probabilities are calculated as followed:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig11.png" />
</div>
<p>If the observed grouped allele number is higher than the <strong>expected value - the maximal standard deviation</strong> a probability of 1 is attributed. This probability is the probability to have at least X haplotypes in the analysed region. If the observed value is lower the probability is calculated based on a density probability of a normal distribution of mean value = <strong>expected value - the maximal standard deviation</strong> and sd = <strong>the maximal standard deviation * --sdMult</strong>. By default --sdMult = 1. This density probability is normalized to reach a probability of 1 when the observed value is equal to <strong>expected value - the maximal standard deviation</strong>. The noise probability is calculated following the same phylosophie but this time a probability of 1 is attributed if the observed grouped allele number is lower than the <strong>expected value + the maximal standard deviation</strong>. Else, the probability to be in the noise is calculated based on a density probability of a normal distribution of mean value = <strong>expected value + the maximal standard deviation</strong> and sd = <strong>the maximal standard deviation * --sdMult</strong>. This density probability is normalized to reach a probability of 1 when the observed value is equal to <strong>expected value + the maximal standard deviation</strong>. Based on these probabilities, an ancestral origin is attributed to each haplotypes of the studied accession. The attribution is performed as followed, for each ancestral group if the probability to be in the noise is higher than the probability to be in the group, the probability to be in the group is converted to 0. Then, the haplotype probability is calculated based on the sorting of the maximal probability. If no consensus can be found (<em>ex.</em> incompatible three best probabilities for a diploid) unknown haplotypes are filled. Haplotypes are ordered trying to minimize recombination events. Each haplotypes for or each accessions are outputed in files found in the folder passed in --prefix option and are named as followed: <strong><em>accessionName_chr_haploX.tab</em></strong>. There are as much file as there are haplotypes. In each files there are 5 columns:</p>
<ul>
<li>1 - acessions name</li>
<li>2 - chromosome name</li>
<li>3 - start position of the bloc</li>
<li>4 - end position of the bloc</li>
<li>5 - ancestral origin of the bloc</li>
</ul>
<p>These files will be used to draw figures in the following steps.</p>
<p>All these statistics are also plotted in files named according to the following nomenclature <strong><em>accessionName_chr_density.pdf</em></strong> and can be found in the folder passed in --prefix option. The following Figure is obtained from the accession <em>sample68</em></p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig12.png" />
</div>
<p>This Figure regroup several informations such as the heterozygosity level along the chromosome, for each ancestry the expected number of grouped allele in case of 1 haplotype of this origin (green band), 2 haplotypes of this origin (red band) or the noise (grey band) and the observed number of grouped allele in the accession (black curve). The last graph represent the calculated probabilities and based on these probabilities a chromosome painting is performed. <em>As the color attribution is random, the colors of the chromosome painting may not be the same when your run the program but the blocs should be the same.</em></p>
<h2 id="g---chromosome-painting-visualization">G - Chromosome painting visualization</h2>
<p>The chromsome painting can be vizualized from distinct ways. For example you can have several chromosomes from one accession and you may want to plot all your chromosomes on a single file. This can be done with the following command line:</p>
<pre><code>cd Painting
python3 ../../bin/haplo2kar.1.0.py --acc sample68 --chr RefSeq --gcol ../Final/ClustAnalysis_group_color.tab --dg g1:g2:g3 --centro ../../data/reference/centro_pos.tab --ploidy 2</code></pre>
<p>This command line outpout a pdf named <strong><em>sample68.pdf</em></strong> which should look like this:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig13.png" />
</div>
<p>This is not very different from the previous Figure but the idea was just to try the command line. You can also observe that pericentromeric regions (located by the ../../data/reference/centro_pos.tab file) are located in the figure with the grey lines while chromosome arms are identified with black lines.</p>
<p>Just to have an idea of what it looks like when you have several chromosomes you can do the following. Create new files from other accessions that will simulate new chromosomes:</p>
<pre><code>sed &#39;s/RefSeq/RefSeq1/&#39; sample7_RefSeq_haplo1.tab &gt; sample68_RefSeq1_haplo1.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample7_RefSeq_haplo2.tab &gt; sample68_RefSeq1_haplo2.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample66_RefSeq_haplo1.tab &gt; sample68_RefSeq2_haplo1.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample66_RefSeq_haplo2.tab &gt; sample68_RefSeq2_haplo2.tab</code></pre>
<p>At this point we have generated 2 additionnals chromosomes (RefSeq1 and RefSeq2) for sample68 which are in fact the chromosome painting of sample7 and sample66. To do the chromosoime painting of this &quot;false&quot; accession run the following command line:</p>
<pre><code>python3 ../../bin/haplo2kar.1.0.py --acc sample68 --chr RefSeq:RefSeq1:RefSeq2 --gcol ../Final/ClustAnalysis_group_color.tab --dg g1:g2:g3 --centro ../../data/reference/centro_pos.tab --ploidy 2</code></pre>
<p>This command line overwrite the original Figure and the outpout should look like this:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig14.png" />
</div>
<p>You can observe our three chromosomes (RefSeq, RefSeq1 and RefSeq2) of the same accession in one Figure.</p>
<p>You may also want compare the chromosome painting of several accessions. <em>i.e.</em> to plot the chromosome painting of several accessions but for one chromosome in one figure. For example you want to see the chromosome painting of all admixed accessions.</p>
<p>Fisrt create the liste of admixed accession with in column 2 the ploidy level:</p>
<pre><code>tail -n 10 ../DNAseq_names.tab | sed &#39;s/$/\t2/&#39; &gt; ../DNAseq_names_admix.tab</code></pre>
<p>Then create the Figure:</p>
<pre><code>python3 ../../bin/haplo2karByChr.1.0.py --acc ../DNAseq_names_admix.tab --chr RefSeq --gcol ../Final/ClustAnalysis_group_color.tab --dg g1:g2:g3 --centro ../../data/reference/centro_pos.tab --prefix All_Admix </code></pre>
<p>This command creates a file named <strong><em>All_Admix_RefSeq_1.pdf</em></strong> which contained haplotypes for accessions passed in --acc option. The outpout should look like this (at the bottom of the page):</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig15.png" />
</div>
<p>This program is designed to print at most 53 (default parameters) chromosome per pages, if you have more chromosomes to draw, if this parameters is not changed the first 53 haplotypes will be drawn in a fisrt pdf called <strong><em>All_Admix_RefSeq_1.pdf</em></strong> and the remaining will be drawn in a pdf called <strong><em>All_Admix_RefSeq_2.pdf</em></strong>. You can also change the --maxChr parameters to draw more chromosomes per pdf.</p>
<p>And finally, you may also want to generate a circos representation of your data with several accessions and chromosomes in the same Figure. This can be done with the haplo2Circos.1.0.py. This can be done with the following command line:</p>
<pre><code>python3 ../../bin/haplo2Circos.1.0.py --acc ../DNAseq_names_admix.tab --chr RefSeq --gcol ../Final/ClustAnalysis_group_color.tab --dg g1:g2:g3 --centro ../../data/reference/centro_pos.tab --prefix Circos_All_Admix</code></pre>
<p>This programs outpouts 4 files:</p>
<ul>
<li><strong>Circos_All_Admix.conf</strong>: the configuration file used by circos. I choose to keep this file so that it can be edited to change aspect of the Figure if you want. After editing this file you will only have to run the following command line to have your new Figure : <em>circos -conf Circos_All_Admix.conf -noparanoid</em></li>
<li><strong>Circos_All_Admix_housekeeping.conf</strong>: a second file used by circos,</li>
<li><strong>Circos_All_Admix.kar</strong>: a third file also used by circos,</li>
<li><strong>Circos_All_Admix.png</strong>: the circos Figure</li>
</ul>
<p>The Figure obtained should look like this:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig16.png" />
</div>
<p>In the circos picture, accessions are ordered from the outside to the inside in following the order passed in --acc option.</p>
<p>Again in this example, because we do not have more than one chromosome, we will do the same thing than previously for sample68: we will generate 2 additionnal chromosomes for 4 other accessions to have an idea of what the circos looks like whit several chromosomes.</p>
<pre><code>sed &#39;s/RefSeq/RefSeq1/&#39; sample21_RefSeq_haplo1.tab &gt; sample67_RefSeq1_haplo1.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample21_RefSeq_haplo2.tab &gt; sample67_RefSeq1_haplo2.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample65_RefSeq_haplo1.tab &gt; sample67_RefSeq2_haplo1.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample65_RefSeq_haplo2.tab &gt; sample67_RefSeq2_haplo2.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample40_RefSeq_haplo1.tab &gt; sample69_RefSeq1_haplo1.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample40_RefSeq_haplo2.tab &gt; sample69_RefSeq1_haplo2.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample64_RefSeq_haplo1.tab &gt; sample69_RefSeq2_haplo1.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample64_RefSeq_haplo2.tab &gt; sample69_RefSeq2_haplo2.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample5_RefSeq_haplo1.tab &gt; sample61_RefSeq1_haplo1.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample5_RefSeq_haplo2.tab &gt; sample61_RefSeq1_haplo2.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample63_RefSeq_haplo1.tab &gt; sample61_RefSeq2_haplo1.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample63_RefSeq_haplo2.tab &gt; sample61_RefSeq2_haplo2.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample45_RefSeq_haplo1.tab &gt; sample70_RefSeq1_haplo1.tab
sed &#39;s/RefSeq/RefSeq1/&#39; sample45_RefSeq_haplo2.tab &gt; sample70_RefSeq1_haplo2.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample62_RefSeq_haplo1.tab &gt; sample70_RefSeq2_haplo1.tab
sed &#39;s/RefSeq/RefSeq2/&#39; sample62_RefSeq_haplo2.tab &gt; sample70_RefSeq2_haplo2.tab</code></pre>
<p>We also need to generate the configuration file to pass to the --acc option:</p>
<pre><code>echo &quot;sample67 2&quot; &gt; for_circos.tab
echo &quot;sample68 2&quot; &gt;&gt; for_circos.tab
echo &quot;sample69 2&quot; &gt;&gt; for_circos.tab
echo &quot;sample61 2&quot; &gt;&gt; for_circos.tab
echo &quot;sample70 2&quot; &gt;&gt; for_circos.tab</code></pre>
<p>And then, it is time to draw the Circos:</p>
<pre><code>python3 ../../bin/haplo2Circos.1.0.py --acc for_circos.tab --chr RefSeq:RefSeq1:RefSeq2 --gcol ../Final/ClustAnalysis_group_color.tab --dg g1:g2:g3 --centro ../../data/reference/centro_pos.tab --prefix Circos_Acc</code></pre>
<p>The output should look like this:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/Vcf2struct_Fig17.png" />
</div>
<h2 id="h---e-chromosome-painting-using-non-admixed-ancestral-accessions">H - E-chromosome painting using non admixed ancestral accessions</h2>
<p>This section aimed at studying the ancestral contribution along chromosomes of one accession or a group of accessions. This program will work if a set of ancestral accessions is available. These accessions should have no introgressions.</p>
<h3 id="available-data-1">Available data:</h3>
<p><em>data/config/Origin.tab</em> is a file which contained two column: a first column containing ancestral accession names and a second column containing their ancestral origin (this program can work until 8 distinct origins). <em>data/config/Origin.tab</em> is a file which contained path to vcf files which will be used for e-chromosome painting. <em>data/vcf/</em> is a folder containing the vcf for 5 chromosomes on 15 accessions which will be used in this tutorial.</p>
<h3 id="principle">Principle:</h3>
<p>The programs described in this section performed two type of analysis: it performs a chromosome painting along accessions according to ancestral accessions defined and it also perform a plot of read coverage along the chromosome to identify aneuploidy.</p>
<p>These programs worked as follows: based on the vcf file provided and the accession origin each allele is attributed to an ancestor according to the following rule (two distinct rules are available):</p>
<p>rule1 - An allele is attributed to a group if it has been found only in this group. or rule2 - An allele is attributed to a group if it has been found in all members of the group and absent from members of others groups.</p>
<p>Hence, for each grouped alleles, and for the studied accession, the number of read having this allele is calculated and divided by the number of reads at the position in the studied accession. In this context, a diploid accession having two chromosomes of the same origin (ex. red) should have a red allele ratio near 1 (see Figure below (A)). A diploid accessions with chromosomes of two distinct origin (ex. one red and one green) should have green allele ratio near 0.5 and red allele ratio near 0.5 too (see Figure below (B)). A same approach can be applied to polyploid accessions: with a ratio of 0.33 and 0.66 for one and two ancestral chromosomes of the same origin respectively for triploid (see Figure below (C)) and a ratio of 0.25, 0.5, 0.75 for one, two and three ancestral chromosomes of the same origin respectively for tetraploid accession (see Figure below (D)).</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/AllelePropAndCov_Fig1.png" />
</div>
<p>In addition, for each position where an allele can be attributed to a group, the read coverage for the accession is calculated. An average coverage is then calculated for the accession and read coverage along the chromosome of the accession is then plotted relative to the average coverage of the accession. This approach allow to identify missing or supernumerary chromosomes (or chromosomal region) (See Figure below).</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/AllelePropAndCov_Fig2.png" />
</div>
<h3 id="running-analysis">Running analysis</h3>
<p>Two programs are available and can be run depending on what figures you expect. The first program allowed to perform a chromosome painting for all chromosome of one accessions.</p>
<p>Goes to the TestTools folder and run the following command line:</p>
<pre><code>../bin/vcf2allPropAndCov.py --conf ../data/config/Vcf.conf --origin ../data/config/Origin.tab --acc Kunnan --ploidy 2 --NoMiss n --all y</code></pre>
<p>This command line analyse the &quot;Kunnan&quot; accession (--acc Kunnan) on chromosome 1,2,3,4 and 9 found in the vcf passed as a list to --conf ../data/config/Vcf.conf option. Alleles were grouped according to accessions origin file passed to --origin ../data/config/Origin.tab option. To attribute allele origin, ancestral accession can have missing data (--NoMiss n) but all accessions without missing data should have the allele (--all y). <strong>Remark:</strong> For any options passed, for a SNP position, if an ancestral group as all its accessions with missing data, the SNP position is not used by the program.</p>
<p>This programs outpouts 4 files:</p>
<ul>
<li><strong>Kunnan_AlleleOriginAndRatio.tab</strong> is a file describing for each grouped allele, its origin and the proportion of reads having this allele at the studied position in the accession.</li>
<li><strong>Kunnan_stats.tab</strong> is a file reporting statistics on SNP sites used, sites where an allele is attributed to each groups and alleles number attributed to each groups in the accession.</li>
<li><strong>KunnanCov.png</strong> is a figure showing read coverage along chromosomes (see figure below for interpretation).</li>
<li><strong>KunnanRatio.png</strong>: is a figure showing grouped allele read ratio along chromosomes (see figure below for interpretation).</li>
</ul>
<p>The following figure describe the two outputs of the program and how to interpret these outputs. In this tutorial, the two ancestral groups are named &quot;AA&quot; and &quot;BB&quot; and as colors are arbitrarily attributed based on an alphanumeric sorting of ancestor names and first color is green and second is red, then &quot;AA&quot; is green and &quot;BB&quot; is red.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/AllelePropAndCov_Fig3.png" />
</div>
<p>Their is 3 additional admixed accessions, two triploids (GP1 and P025) and a tetraploid one P1. These accessions can also be analysed as Kunnan with the following command lines:</p>
<pre><code>../bin/vcf2allPropAndCov.py --conf ../data/config/Vcf.conf --origin ../data/config/Origin.tab --acc GP1 --ploidy 3 --NoMiss n --all y
../bin/vcf2allPropAndCov.py --conf ../data/config/Vcf.conf --origin ../data/config/Origin.tab --acc P025 --ploidy 3 --NoMiss n --all y
../bin/vcf2allPropAndCov.py --conf ../data/config/Vcf.conf --origin ../data/config/Origin.tab --acc P1 --ploidy 4 --NoMiss n --all y</code></pre>
<p>The following figure is the picture of SNP read coverage you should obtain and the interpretation that can be made from this coverage. We can observe that for accession P025 a chromosome region is missing for the start of chromosome 1 and the major part of chromosome 3.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/AllelePropAndCov_Fig4.png" />
</div>
<p>The following figure is the picture of allele ratio you should obtain and green and red bars represent the interpretation that can be made from this allele ratio and read coverage.</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/AllelePropAndCov_Fig5.png" />
</div>
<p>One also want to perform this same analysis but by comparing one chromosome from several accessions. This can be performed with the following command line:</p>
<pre><code>../bin/vcf2allPropAndCovByChr.py --conf ../data/config/Vcf.conf --origin ../data/config/Origin.tab --ploidy 3 --NoMiss n --all y --acc T04,T02,Kunnan,GP1,P025,P1</code></pre>
<p>This command line analyse T04, T02, Kunnan, GP1, P025 and P1 accessions (--acc T04,T02,Kunnan,GP1,P025,P1) on chromosome 1,2,3,4 and 9 found in the vcf passed as a list to --conf ../data/config/Vcf.conf option. Alleles were grouped according to accessions origin file passed to --origin ../data/config/Origin.tab option. To attribute allele origin, ancestral accession can have missing data (--NoMiss n) but all accessions without missing data should have the allele (--all y). <strong>Remark:</strong> If the --acc option is omitted, the picture will be drawn for all accessions found in the vcf. No more than 15 chromosomes are drawn per figures. If there are more than 15 chromosomes, they are drawn in a second file, a thrid, etc...</p>
<p>Two types of file are generated for each chromosomes. The coverage file and the allele ratio file. Here is an exemple of file generated for chromosome 3 on the 4 tested accessions:</p>
<div class="figure">
<img src="http://banana-genome-http.cirad.fr/image/AllelePropAndCov_Fig6.png" />
</div>
<p>In this figure, chromosome 3 of all tested accessions are represented in the same figure. We added T04 and T02 which are accessions representative of ancestors green and red, respectively. These accessions are not required but I think that it might be important to show you that we can also analyze accessions which are used as ancestor. It is also important to verify that their is no introgression in accessions used as ancestor. by doing this, this can be verified because according to our rules of ancestor specific allele attribution, an introgression of a red region in a green ancestor would result in the absence of red allele specific attribution in the introgressed region. And this can be verified studying the allele ratio in ancestor. One can also observe that an arbitrary ploidy level as been passed. This is due to the fact that this program cannot manage distinct ploidy level at the same time. However, this is not a problem, because this ploidy level is only used to estimate the expected coverage in case of supernumerary or missing regions in coverage analysis (horizontal lines in coverage figures). Thus these line will not be exact if the ploidy level is not the good one but the identification of supernumerary or missing regions will not be perturbed.</p>
<h2 id="i---miscellaneous">I - Miscellaneous</h2>
<p>In this tutorial I have described main tools starting from fastq and finishing with chromosome painting. However, the the Vcf2struct.1.0.py allowed to perform several other tasks which are described in the <strong><em>README</em></strong> file. You can try them if you want.</p>
<p>In addition, once allele grouping as been performed, the analysis can be also perfomed on the RNAseq data, even if they have not been used in the analysis! Go to the TestTools folder and run the following command line:</p>
<pre><code>python3 ../bin/vcf2linear.1.1.py --vcf DNA_RNAseq_final_filt.vcf --names RNAseq_names.tab --namesH ancestor.gp --win 100 --mat Final/ClustAnalysis_kMean_allele.tab --prefix Painting --gcol Final/ClustAnalysis_group_color.tab --chr RefSeq --ploidy 2</code></pre>
<p>The ouput are the same as for the DNAseq data. The only difference is that the analysis will only be performed on site of grouped alleles also present in the RNAseq dataset.</p>
